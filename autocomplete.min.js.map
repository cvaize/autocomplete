{"version":3,"file":"autocomplete.min.js","sources":["autocomplete.ts"],"sourcesContent":[" /*\n  * https://github.com/kraaden/autocomplete\n  * Copyright (c) 2016 Denys Krasnoshchok\n  * MIT License\n  */\n\nexport const enum EventTrigger {\n    Keyboard = 0,\n    Focus = 1\n}\n\nexport interface AutocompleteItem {\n    label?: string;\n    group?: string;\n}\n\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\n    input: HTMLInputElement;\n    render?: (item: T, currentValue: string) => HTMLDivElement | undefined;\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\n    className?: string;\n    minLength?: number;\n    emptyMsg?: string;\n    onSelect: (item: T, input: HTMLInputElement) => void;\n    /**\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\n     */\n    showOnFocus?: boolean;\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger) => void;\n    debounceWaitMs?: number;\n    /**\n     * Callback for additional autocomplete customization\n     * @param {HTMLInputElement} input - input box associated with autocomplete\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\n     * @param {HTMLDivElement} container - container with suggestions\n     * @param {number} maxHeight - max height that can be used by autocomplete\n     */\n    customize?: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n    /**\n     * Prevents automatic form submit when ENTER is pressed\n     */\n    preventSubmit?: boolean;\n}\n\nexport interface AutocompleteResult {\n    destroy: () => void;\n}\n\nconst enum Keys {\n    Enter = 13,\n    Esc = 27,\n    Up = 38,\n    Down = 40,\n    Left = 37,\n    Right = 39,\n    Shift = 16,\n    Ctrl = 17,\n    Alt = 18,\n    CapsLock = 20,\n    WindowsKey = 91,\n    Tab = 9\n}\n\nexport default function autocomplete<T extends AutocompleteItem>(settings: AutocompleteSettings<T>): AutocompleteResult {\n\n    // just an alias to minimize JS file size\n    const doc = document;\n\n    const container: HTMLDivElement = doc.createElement(\"div\");\n    const containerStyle = container.style;\n    const userAgent = navigator.userAgent;\n    const mobileFirefox = userAgent.indexOf(\"Firefox\") !== -1 && userAgent.indexOf(\"Mobile\") !== -1;\n    const debounceWaitMs = settings.debounceWaitMs || 0;\n    const preventSubmit = settings.preventSubmit || false;\n\n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\n    const keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\n\n    let items: T[] = [];\n    let inputValue = \"\";\n    let minLen = 2;\n    const showOnFocus = settings.showOnFocus;\n    let selected: T | undefined;\n    let keypressCounter = 0;\n    let debounceTimer : number | undefined;\n\n    if (settings.minLength !== undefined) {\n        minLen = settings.minLength;\n    }\n\n    if (!settings.input) {\n        throw new Error(\"input undefined\");\n    }\n\n    const input: HTMLInputElement = settings.input;\n\n    container.className = \"autocomplete \" + (settings.className || \"\");\n    containerStyle.position = \"fixed\";\n\n    /**\n     * Detach the container from DOM\n     */\n    function detach(): void {\n        const parent = container.parentNode;\n        if (parent) {\n            parent.removeChild(container);\n        }\n    }\n\n    /**\n     * Clear debouncing timer if assigned\n     */\n    function clearDebounceTimer(): void {\n        if (debounceTimer) {\n            window.clearTimeout(debounceTimer);\n        }\n    }\n\n    /**\n     * Attach the container to DOM\n     */\n    function attach(): void {\n        if (!container.parentNode) {\n            doc.body.appendChild(container);\n        }\n    }\n\n    /**\n     * Check if container for autocomplete is displayed\n     */\n    function containerDisplayed(): boolean {\n        return !!container.parentNode;\n    }\n\n    /**\n     * Clear autocomplete state and hide container\n     */\n    function clear(): void {\n        keypressCounter++;\n        items = [];\n        inputValue = \"\";\n        selected = undefined;\n        detach();\n    }\n\n    /**\n     * Update autocomplete position\n     */\n    function updatePosition(): void {\n        if (!containerDisplayed()) {\n            return;\n        }\n\n        containerStyle.height = \"auto\";\n        containerStyle.width = input.offsetWidth + \"px\";\n\n        const inputRect = input.getBoundingClientRect();\n        let top = inputRect.top;\n\n        top = top + input.offsetHeight;\n\n        let maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\n\n        if (maxHeight < 0) {\n            maxHeight = 0;\n        }\n\n        containerStyle.top = top + \"px\";\n        containerStyle.bottom = \"\";\n        containerStyle.left = inputRect.left + \"px\";\n        containerStyle.maxHeight = maxHeight + \"px\";\n\n        if (settings.customize) {\n            settings.customize(input, inputRect, container, maxHeight);\n        }\n    }\n\n    /**\n     * Redraw the autocomplete div element with suggestions\n     */\n    function update(): void {\n\n        // delete all children from autocomplete DOM container\n        while (container.firstChild) {\n            container.removeChild(container.firstChild);\n        }\n\n        // function for rendering autocomplete suggestions\n        let render = function(item: T, currentValue: string): HTMLDivElement | undefined {\n            const itemElement = doc.createElement(\"div\");\n            itemElement.textContent = item.label || \"\";\n            return itemElement;\n        };\n        if (settings.render) {\n            render = settings.render;\n        }\n\n        // function to render autocomplete groups\n        let renderGroup = function(groupName: string, currentValue: string): HTMLDivElement | undefined {\n            const groupDiv = doc.createElement(\"div\");\n            groupDiv.textContent = groupName;\n            return groupDiv;\n        };\n        if (settings.renderGroup) {\n            renderGroup = settings.renderGroup;\n        }\n\n        const fragment = doc.createDocumentFragment();\n        let prevGroup = \"#9?$\";\n\n        items.forEach(function(item: T): void {\n            if (item.group && item.group !== prevGroup) {\n                prevGroup = item.group;\n                const groupDiv = renderGroup(item.group, inputValue);\n                if (groupDiv) {\n                    groupDiv.className += \" group\";\n                    fragment.appendChild(groupDiv);\n                }\n            }\n            const div = render(item, inputValue);\n            if (div) {\n                div.addEventListener(\"click\", function(ev: MouseEvent): void {\n                    settings.onSelect(item, input);\n                    clear();\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                });\n                if (item === selected) {\n                    div.className += \" selected\";\n                }\n                fragment.appendChild(div);\n            }\n        });\n        container.appendChild(fragment);\n        if (items.length < 1) {\n            if (settings.emptyMsg) {\n                const empty = doc.createElement(\"div\");\n                empty.className = \"empty\";\n                empty.textContent = settings.emptyMsg;\n                container.appendChild(empty);\n            } else {\n                clear();\n                return;\n            }\n        }\n\n        attach();\n        updatePosition();\n\n        updateScroll();\n    }\n\n    function updateIfDisplayed(): void {\n        if (containerDisplayed()) {\n            update();\n        }\n    }\n\n    function resizeEventHandler(): void {\n        updateIfDisplayed();\n    }\n\n    function scrollEventHandler(e: Event): void {\n        if (e.target !== container) {\n            updateIfDisplayed();\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    function keyupEventHandler(ev: KeyboardEvent): void {\n        const keyCode = ev.which || ev.keyCode || 0;\n\n        const ignore = [Keys.Up, Keys.Enter, Keys.Esc, Keys.Right, Keys.Left, Keys.Shift, Keys.Ctrl, Keys.Alt, Keys.CapsLock, Keys.WindowsKey, Keys.Tab];\n        for (const key of ignore) {\n            if (keyCode === key) {\n                return;\n            }\n        }\n\n        // the down key is used to open autocomplete\n        if (keyCode === Keys.Down && containerDisplayed()) {\n            return;\n        }\n\n        startFetch(EventTrigger.Keyboard);\n    }\n\n    /**\n     * Automatically move scroll bar if selected item is not visible\n     */\n    function updateScroll(): void {\n        const elements = container.getElementsByClassName(\"selected\");\n        if (elements.length > 0) {\n            let element = elements[0] as HTMLDivElement;\n\n            // make group visible\n            const previous = element.previousElementSibling as HTMLDivElement;\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\n                element = previous;\n            }\n\n            if (element.offsetTop < container.scrollTop) {\n                container.scrollTop = element.offsetTop;\n            } else {\n                const selectBottom = element.offsetTop + element.offsetHeight;\n                const containerBottom = container.scrollTop + container.offsetHeight;\n                if (selectBottom > containerBottom) {\n                    container.scrollTop += selectBottom - containerBottom;\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the previous item in suggestions\n     */\n    function selectPrev(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        } else {\n            if (selected === items[0]) {\n                selected = items[items.length - 1];\n            } else {\n                for (let i = items.length - 1; i > 0; i--) {\n                    if (selected === items[i] || i === 1) {\n                        selected = items[i - 1];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the next item in suggestions\n     */\n    function selectNext(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        }\n        if (!selected || selected === items[items.length - 1]) {\n            selected = items[0];\n            return;\n        }\n        for (let i = 0; i < (items.length - 1); i++) {\n            if (selected === items[i]) {\n                selected = items[i + 1];\n                break;\n            }\n        }\n    }\n\n    function keydownEventHandler(ev: KeyboardEvent): void {\n        const keyCode = ev.which || ev.keyCode || 0;\n\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\n            const containerIsDisplayed = containerDisplayed();\n\n            if (keyCode === Keys.Esc) {\n                clear();\n            } else {\n                if (!containerDisplayed || items.length < 1) {\n                    return;\n                }\n                keyCode === Keys.Up\n                    ? selectPrev()\n                    : selectNext();\n                update();\n            }\n\n            ev.preventDefault();\n            if (containerIsDisplayed) {\n                ev.stopPropagation();\n            }\n\n            return;\n        }\n\n        if (keyCode === Keys.Enter) {\n            if (selected) {\n                settings.onSelect(selected, input);\n                clear();\n            }\n\n            if (preventSubmit) {\n                ev.preventDefault();\n            }\n        }\n    }\n\n    function focusEventHandler(): void {\n        if (showOnFocus) {\n            startFetch(EventTrigger.Focus);\n        }\n    }\n\n    function startFetch(trigger: EventTrigger) {\n        // if multiple keys were pressed, before we get update from server,\n        // this may cause redrawing our autocomplete multiple times after the last key press.\n        // to avoid this, the number of times keyboard was pressed will be\n        // saved and checked before redraw our autocomplete box.\n        const savedKeypressCounter = ++keypressCounter;\n\n        const val = input.value;\n        if (val.length >= minLen || trigger === EventTrigger.Focus) {\n            clearDebounceTimer();\n            debounceTimer = window.setTimeout(function(): void {\n                settings.fetch(val, function(elements: T[] | false): void {\n                    if (keypressCounter === savedKeypressCounter && elements) {\n                        items = elements;\n                        inputValue = val;\n                        selected = items.length > 0 ? items[0] : undefined;\n                        update();\n                    }\n                }, EventTrigger.Keyboard);\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\n        } else {\n            clear();\n        }\n    }\n\n    function blurEventHandler(): void {\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n        setTimeout(() => {\n            if (doc.activeElement !== input) {\n                clear();\n            }\n        }, 200);\n    }\n\n    /**\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\n     */\n    container.addEventListener(\"mousedown\", function(evt: Event) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    });\n\n    /**\n     * This function will remove DOM elements and clear event handlers\n     */\n    function destroy(): void {\n        input.removeEventListener(\"focus\", focusEventHandler);\n        input.removeEventListener(\"keydown\", keydownEventHandler);\n        input.removeEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\n        input.removeEventListener(\"blur\", blurEventHandler);\n        window.removeEventListener(\"resize\", resizeEventHandler);\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\n        clearDebounceTimer();\n        clear();\n\n        // prevent the update call if there are pending AJAX requests\n        keypressCounter++;\n    }\n\n    // setup event handlers\n    input.addEventListener(\"keydown\", keydownEventHandler);\n    input.addEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener(\"blur\", blurEventHandler);\n    input.addEventListener(\"focus\", focusEventHandler);\n    window.addEventListener(\"resize\", resizeEventHandler);\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\n\n    return {\n        destroy\n    };\n}\n"],"names":["settings","selected","debounceTimer","doc","document","container","createElement","containerStyle","style","userAgent","navigator","mobileFirefox","indexOf","debounceWaitMs","preventSubmit","keyUpEventName","items","inputValue","minLen","showOnFocus","keypressCounter","undefined","minLength","input","Error","clearDebounceTimer","window","clearTimeout","containerDisplayed","parentNode","clear","parent","removeChild","update","firstChild","render","item","currentValue","itemElement","textContent","label","renderGroup","groupName","groupDiv","fragment","createDocumentFragment","prevGroup","forEach","group","className","appendChild","div","addEventListener","ev","onSelect","preventDefault","stopPropagation","length","emptyMsg","empty","body","height","width","offsetWidth","inputRect","getBoundingClientRect","top","offsetHeight","maxHeight","innerHeight","bottom","left","customize","updatePosition","elements","getElementsByClassName","element","previous","previousElementSibling","offsetTop","scrollTop","selectBottom","containerBottom","updateScroll","updateIfDisplayed","resizeEventHandler","scrollEventHandler","e","target","keyupEventHandler","keyCode","which","ignore_1","_i","startFetch","keydownEventHandler","containerIsDisplayed","i","selectPrev","selectNext","focusEventHandler","trigger","savedKeypressCounter","val","value","setTimeout","fetch","blurEventHandler","activeElement","position","evt","destroy","removeEventListener"],"mappings":"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"}